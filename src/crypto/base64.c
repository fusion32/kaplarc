#include "base64.h"

static const uint8 base64[] =
	"./"
	"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
	"abcdefghijklmnopqrstuvwxyz"
	"0123456789";

static const uint8 decode64[] = {
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x01,
	0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D,
	0x3E, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
	0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,
	0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
	0x19, 0x1A, 0x1B, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22,
	0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A,
	0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32,
	0x33, 0x34, 0x35, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
};

bool base64_encode(char *b64data, const uint8 *data, size_t len){
	const uint8 *p = data;
	uint8 *out = (uint8*)b64data;
	size_t n = len / 3;

	while(n > 0){
		out[0] = base64[p[0] >> 2];
		out[1] = base64[((p[0] & 0x03) << 4) | ((p[1] >> 4) & 0x0F)];
		out[2] = base64[((p[1] & 0x0F) << 2) | ((p[2] >> 6) & 0x03)];
		out[3] = base64[p[2] & 0x3F];
		out += 4; p += 3; n -= 1;
	}

	switch(len % 3){
	case 1:
		out[0] = base64[p[0] >> 2];
		out[1] = base64[(p[0] & 0x03) << 4];
		out += 2;
		break;
	case 2:
		out[0] = base64[p[0] >> 2];
		out[1] = base64[((p[0] & 0x03) << 4) | ((p[1] >> 4) & 0x0F)];
		out[2] = base64[(p[1] & 0x0F) << 2];
		out += 3;
		break;
	}
	*out = 0x00;
	return true;
}

bool base64_decode(uint8 *data, size_t len, const char *b64data){
	const uint8 *p = (const uint8*)b64data;
	uint8 *out = data;
	uint8 c1, c2, c3, c4;
	size_t n = len / 3;

	while(n > 0){
		c1 = decode64[p[0]]; c2 = decode64[p[1]];
		c3 = decode64[p[2]]; c4 = decode64[p[3]];
		if(c1 == 0xFF || c2 == 0xFF || c3 == 0xFF || c4 == 0xFF)
			return false;
		out[0] = (c1 << 2) | ((c2 >> 4) & 0x03);
		out[1] = ((c2 & 0x0F) << 4) | ((c3 >> 2) & 0x0F);
		out[2] = ((c3 & 0x03) << 6) | c4;
		out += 3; p += 4; n -= 1;
	}

	switch(len % 3){
	case 1:
		c1 = decode64[p[0]];
		c2 = decode64[p[1]];
		if(c1 == 0xFF || c2 == 0xFF)
			return false;
		*out++ = (c1 << 2) | ((c2 >> 4) & 0x03);
		break;

	case 2:
		c1 = decode64[p[0]];
		c2 = decode64[p[1]];
		c3 = decode64[p[2]];
		if(c1 == 0xFF || c2 == 0xFF || c3 == 0xFF)
			return false;
		out[0] = (c1 << 2) | ((c2 >> 4) & 0x03);
		out[1] = ((c2 & 0x0F) << 4) | ((c3 >> 2) & 0x0F);
		out += 2;
		break;
	}

	return true;
}
